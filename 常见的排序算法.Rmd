---
title: "常见的几种排序方法"
author: "linsq"
date: "2017年4月11日"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

本文参照：算法导论


##插入排序


输入：n个数的一个序列$(a_1,a_2,\cdots,a_n)$.            输出：输入序列的有序排列$(a'_1,a'_2,\cdots,a'_n)$,满足$a'_1\leq a'_2 \leq \cdots \le a'_n$

适用于：少量元素的排序。                
工作方式：类似于排序一手扑克牌。开始时，我们的左手为空并且桌上的牌面向下。然后。我们每次从桌上拿走一张牌并将它插入左手中的正确位置。为了找到一张牌的正确位置，我们从右到左将它与以在手中的每张牌进行比较，拿在左手上的牌总是排序好的，原来的这些牌时桌上牌堆中顶部的牌。


算法：对一个数组A[1,...,n]          
INSERTION—SORT(A):              
  for j=2 to A.length           
      key=A[j]          
      //Insert A[j] into the sorted sequence A[1,...,j-1]               
      i=j-1             
      while i>0 and A[j]>key            
            A[i+1]=A[i]         
            i=i-1               
      A[i+1]=key


R代码
```{r}
a <- c(31,41,59,26,41,58)


insertionsort <- function(x){
        for(j in 2:length(x)){
                key <- x[j]
                i <- j-1
                while(i>0){
                        if(x[i]>key){
                                x[i+1] <- x[i]
                                x[i] <- key
                        }
                        i=i-1
                }
        }
        return(x)
}

insertionsort(a)
```
注意：如果完全按照伪代码来写，由于R中序列是从1而不是从0开始的，在当i=0时判断i>0 and A[j]>key会报错。但是目前这个代码遍历的次数会更多，无法即时终止。

插入排序时间复杂度最好为O(n),最差为O(n^2),平均情况为O(n^2),空间复杂度为O(1)，结果稳定。


##冒泡排序

冒泡排序是一种流行但是低效的排序算法，它的作用时反复交换相邻的未按次序排列的元素。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。

算法：          
BUBBLESORT(A):          
  for i=1 and A.length-1
        for j=A.length downto i+1               
                ifA[j]<A[j-1]           
                        exchangeA[j] with A[j-1]

R代码：
```{r}
bubblesort <- function(x){
        n <- length(x)
        for(i in 1:(n-1)){
                for(j in (i+1):n){
                        if(x[i]>=x[j]){
                                m <- x[j]
                                x[j]=x[i]
                                x[i]=m
                        }
                }
        }
        return(x)
}

bubblesort(a)

```

冒泡排序时间复杂度最好为O(n),最差为O(n^2),平均情况为O(n^2),空间复杂度为O(1)，结果稳定。同上。


##快速排序


